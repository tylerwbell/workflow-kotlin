package com.squareup.workflow1.ui

import android.content.Context
import android.content.ContextWrapper
import android.view.View
import android.view.ViewGroup
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.ViewTreeLifecycleOwner
import androidx.savedstate.SavedStateRegistryOwner
import androidx.savedstate.ViewTreeSavedStateRegistryOwner

/**
 * Namespace for some helper functions for interacting with the AndroidX libraries.
 */
public object WorkflowAndroidXSupport {

  /**
   * Tries to get the parent lifecycle from the current view via [ViewTreeLifecycleOwner], if that
   * fails it looks up the context chain for a [LifecycleOwner], and if that fails it just returns
   *  null.
   */
  @WorkflowUiExperimentalApi
  public fun lifecycleOwnerFromViewTreeOrContext(view: View): LifecycleOwner? =
    ViewTreeLifecycleOwner.get(view) ?: view.context.lifecycleOwnerOrNull()

  /**
   * Tries to get the parent [SavedStateRegistryOwner] from the current view's view via
   * [ViewTreeSavedStateRegistryOwner], if that fails it looks up the context chain for a one,
   * and if that fails it just returns null.
   */
  @WorkflowUiExperimentalApi
  public fun savedStateRegistryOwnerFromViewTreeOrContext(view: View): SavedStateRegistryOwner? =
    ViewTreeSavedStateRegistryOwner.get(view) ?: view.context.savedStateRegistryOwnerOrNull()

  /**
   * Computes a string key for using with a `SavedStateRegistry` that will be globally unique.
   * Requires View IDs to be set for any views that are siblings and have the same rendering type.
   * The key is generated by combining the rendering [compatibility keys][Named.keyFor] of each
   * rendering starting with the current one and going up the view tree to the root. Each rendering
   * key is also associated with the ID of the [View] it's tagged on.
   */
  @WorkflowUiExperimentalApi
  public fun compositeViewIdKey(view: View): String {
    return generateSequence(view) { it.parent as? ViewGroup }
      // This will generate the list of ancestor IDs from child -> parent, so it will be in the
      // reverse order we want (child/parent/root).
      .map { it.id.toString() }
      // Sequences can only be iterated in order, so we need a list to reverse it.
      .toMutableList()
      // Reverse in-place.
      .apply { reverse() }
      .joinToString(separator = "/")
  }

  private tailrec fun Context.lifecycleOwnerOrNull(): LifecycleOwner? = when (this) {
    is LifecycleOwner -> this
    else -> (this as? ContextWrapper)?.baseContext?.lifecycleOwnerOrNull()
  }

  private tailrec fun Context.savedStateRegistryOwnerOrNull(): SavedStateRegistryOwner? =
    when (this) {
      is SavedStateRegistryOwner -> this
      else -> (this as? ContextWrapper)?.baseContext?.savedStateRegistryOwnerOrNull()
    }
}
